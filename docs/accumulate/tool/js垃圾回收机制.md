## JS 高程中的垃圾回收机制与常见内存泄露的解决方法

起因是因为想了解闭包的内存泄露机制，然后想起《js 高级程序设计》中有关于垃圾回收机制的解析，之前没有很懂，过一年回头再看就懂了，写篇博客与大家分享一下。

### 内存的生命周期：

1. 分配你所需要的内存：

由于字符串、对象等没有固定的大小，js 程序在每次创建字符串、对象的时候，程序都会**分配内存来存储那个实体**。

2. 使用分配到的内存做点什么。

3. 不需要时将其释放回归：

在不需要字符串、对象的时候，需要释放其所占用的内存，否则将会消耗完系统中所有可用的内存，造成系统崩溃，这就是**垃圾回收机制所存在的意义**。

**所谓的内存泄漏指的是**：由于疏忽或错误造成程序未能释放那些已经不再使用的内存，造成内存的浪费。

---

## 垃圾回收机制：

在 C 和 C++之类的语言中，需要手动来管理内存的，这也是造成许多不必要问题的根源。幸运的是，在编写 js 的过程中，内存的分配以及内存的回收完全实现了自动管理，我们不用操心这种事情。

### 垃圾收集机制的原理：

垃圾收集器会按照固定的时间间隔，**周期性的找出不再继续使用的变量，然后释放其占用的内存**。

**什么叫不再继续使用的变量？**

不再使用的变量也就是生命周期结束的变量，是局部变量，局部变量只在函数的执行过程中存在，当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收。

全局变量的生命周期直至浏览器卸载页面才会结束，也就是说**全局变量不会被当成垃圾回收**。

### 标记清除：当前采用的垃圾收集策略

工作原理：

当变量进入环境时(例如在函数中声明一个变量)，将这个变量标记为“进入环境”，当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。

工作流程：

1. 垃圾收集器会在运行的时候会给存储在内存中的**所有变量都加上标记**。
2. **去掉环境中的变量**以及被环境中的变量引用的变量的标记。
3. 那些**还存在标记的变量被视为准备删除的变量**。
4. 最后垃圾收集器会执行最后一步内存清除的工作，**销毁那些带标记的值并回收它们所占用的内存空间**。

到 2008 年为止,IE、Chorme、Fireofx、Safari、Opera **都使用标记清除式的垃圾收集策略**，只不过垃圾收集的时间间隔互有不同。

### 引用计数略：被废弃的垃圾收集策略

循环引用：跟踪记录每个值被引用的技术

在老版本的浏览器中(对，又是 IE)，IE9 以下 BOM 和 DOM 对象就是使用 C++以 COM 对象的形式实现的。

COM 的垃圾收集机制采用的就是引用计数策略，这种机制在出现循环引用的时候永远都释放不掉内存。

```js
let element = document.getElementById('something')
let myObject = new Object()
myObject.element = element // element属性指向dom
element.someThing = myObject // someThing回指myObject 出现循环引用(两个对象一直互相包含 一直存在计数)。
```

解决方式是，当我们不使用它们的时候，手动切断链接：

```js
myObject.element = null
element.someThing = null
```

**淘汰**：

IE9 把 BOM 和 DOM 对象转为了真正的 js 对象，避免了使用这种垃圾收集策略，消除了 IE9 以下常见的内存泄漏的主要原因。

IE7 以下有一个声明狼藉的性能问题，大家了解一下：

1. 256 个变量，4096 个对象(或数组)字面或者 64KB 的字符串，达到任何一个临界值会触发垃圾收集器运行。
2. 如果一个 js 脚本的生命周期一直保有那么多变量，垃圾收集器会一直频繁的运行，引发严重的性能问题。

IE7 已修复这个问题。

---

## 哪些情况会引起内存泄漏？

虽然有垃圾回收机制，但我们在编写代码的时候，有些情况还是会造成内存泄漏，了解这些情况，并在编写程序的时候，注意避免，我们的程序会更具健壮性。

### 意外的全局变量：

上文我们提到了**全局变量不会被当成垃圾回收**，我们在编码中有时会出现下面这种情况：

```js
function foo() {
	this.bar2 = '默认绑定this指向全局' // 全局变量=> window.bar2
	bar = '全局变量' // 没有声明变量 实际上是全局变量=>window.bar
}
foo()
```

当我们使用[默认绑定](https://juejin.im/post/5b3715def265da59af40a630#heading-3)，this 会指向全局，`this.something`也会创建一个全局变量，这一点可能很多人没有注意到。

**解决方法：在函数内使用严格模式 or 细心一点**

```js
function foo() {
	'use strict'
	this.bar2 = '严格模式下this指向undefined'
	bar = '报错'
}
foo()
```

当然我们也可以**手动释放全局变量的内存**：

```js
window.bar = undefined
delete window.bar2
```

### 被遗忘的定时器和回调函数

当**不需要**`setInterval`或者`setTimeout`时，**定时器没有被 clear**，定时器的**回调函数以及内部依赖的变量都不能被回收**，造成内存泄漏。

```js
var someResource = getData();
setInterval(function() {
    var node = document.getElementById('Node');
    if(node) {
        node.innerHTML = JSON.stringify(someResource));
        // 定时器也没有清除
    }
    // node、someResource 存储了大量数据 无法回收
}, 1000);
```

**解决方法**： 在定时器完成工作的时候，手动清除定时器。

### 闭包：

**闭包可以维持函数内局部变量，使其得不到释放，造成内存泄漏**。

```js
function bindEvent() {
	var obj = document.createElement('XXX')
	var unused = function() {
		console.log(obj, '闭包内引用obj obj不会被释放')
	}
	// obj = null;
}
```

**解决方法**：手动解除引用，`obj = null`。

### 循环引用问题

就是 IE9 以下的循环引用问题，上文讲过了。

### 没有清理 DOM 元素引用：

```js
var refA = document.getElementById('refA')
document.body.removeChild(refA) // dom删除了
console.log(refA, 'refA') // 但是还存在引用 能console出整个div 没有被回收
```

不信的话，可以看下这个[dom](https://codepen.io/OBKoro1/pen/vroKbg)。

**解决办法**：`refA = null`;

### console 保存大量数据在内存中。

过多的 console，比如定时器的 console 会导致浏览器卡死。

**解决**：合理利用 console，线上项目尽量少的使用 console，当然如果你要发招聘除外。

---

### 如何避免内存泄漏：

**记住一个原则：不用的东西，及时归还，毕竟你是'借的'嘛**。

1. 减少不必要的全局变量，使用严格模式避免意外创建全局变量。
2. 在你使用完数据后，及时解除引用(闭包中的变量，dom 引用，定时器清除)。
3. 组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。

### 关于内存泄漏：

1. 即使是 1byte 的内存，也叫内存泄漏，并不一定是导致浏览器崩溃、卡顿才能叫做内存泄漏。
2. 一般是堆区内存泄漏，栈区不会泄漏。

基本类型的值存在内存中，被保存在栈内存中，引用类型的值是对象，保存在堆内存中。所以**对象、数组之类的，才会发生内存泄漏**。

3. 使用 chorme 监控内存泄漏，可以看一下这篇[文章](https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/)

## 小结

了解了内存泄漏的原因以及出现的情况，那么我们在编码过程中只要多加注意，就不会发生非常严重的内存泄漏问题。

<!-- 特殊字符串：用于修改/删除markdown的结尾提示语-->

### 点个[Star](https://boom-bo.github.io/web_accumulation)支持我一下~
